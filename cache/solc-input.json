{
  "language": "Solidity",
  "sources": {
    "contracts/7/ShadowGas.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.8.0;\n\nimport \"../6/ILGT.sol\";\n\ninterface IGasToken {\n    function name (  ) external view returns ( string memory);\n    function freeFromUpTo ( address from, uint256 value ) external returns ( uint256 freed );\n    function approve ( address spender, uint256 value ) external returns ( bool success );\n    function totalSupply (  ) external view returns ( uint256 supply );\n    function transferFrom ( address from, address to, uint256 value ) external returns ( bool success );\n    function decimals (  ) external view returns ( uint8 );\n    function freeFrom ( address from, uint256 value ) external returns ( bool success );\n    function freeUpTo ( uint256 value ) external returns ( uint256 freed );\n    function balanceOf ( address owner ) external view returns ( uint256 balance );\n    function symbol (  ) external view returns ( string memory);\n    function mint ( uint256 value ) external;\n    function transfer ( address to, uint256 value ) external returns ( bool success );\n    function free ( uint256 value ) external returns ( bool success );\n    function allowance ( address owner, address spender ) external view returns ( uint256 remaining );\n    function increaseAllowance ( address spender, uint256 addValue ) external returns ( bool success );\n}\n\ncontract ShadowGas {\n\n    /*\n\n        State\n\n    */\n\n    address payable possessor;// contract owner\n    address constant CHI = 0x0000000000004946c0e9F43F4Dee607b0eF1fA1c; // 1inch Chi Token\n    address constant LGT = 0x000000000000C1CB11D5c062901F32D06248CE48; // Liquid Gas Token\n    address constant GST = 0x0000000000b3F879cb30FE243b4Dfee438691c04; // Gas Token on Mainnet\n    address constant GST_KOVAN = 0x0000000000170CcC93903185bE5A2094C870Df62; // Gas Token on Kovan\n\n\n    IGasToken chi = IGasToken(CHI);\n    IGasToken gst = IGasToken(GST_KOVAN);\n    ILGT lgt = ILGT(LGT);\n\n    constructor() {\n        possessor = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function _destroy() public shadowPossession () {\n        selfdestruct(possessor);\n    }\n\n/* -------------------------------------------------------------------------- */\n\n\n    /*\n\n        Modifiers\n\n    */\n\n    modifier shadowPossession() {\n        require(msg.sender == possessor, \"You do not possess this Shadow\");\n        _;\n    }\n\n    modifier lgtDiscount() {\n\n        uint gasStart = gasleft();\n\n        _;\n\n        uint gasSpent = (gasStart - gasleft() + 55000) / 41300;\n\n        uint buyCost = lgt.getEthToTokenOutputPrice(gasSpent);\n\n        if (buyCost < ((18145 * gasSpent) - 24000) * tx.gasprice) {\n\n            lgt.buyAndFree(gasSpent, block.timestamp, msg.sender);\n\n        }\n    }\n\n    modifier chiDiscount() {\n\n        uint gasStart = gasleft();\n        \n        _;\n\n        uint gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        \n        if (chi.balanceOf(address(this)) >= (gasSpent + 14154) / 41947) {\n            chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41947);\n        }\n    }\n\n    modifier gstDiscount() {\n\n        uint gasStart = gasleft();\n\n        _;\n\n        uint gasSpent = 25710 + gasStart - gasleft() * (1148 + 5722 + 150);\n\n        if (gst.balanceOf(address(this)) >= gasSpent) {\n            gst.free(gasSpent);\n        }\n    }\n\n/* -------------------------------------------------------------------------- */\n\n    /*\n\n        Events\n\n    */\n\n    event LgtRefueled(uint _amount, address _refueler, uint _lgtBalance);\n    event LgtEmptied(uint _amount, address _emptier, uint _lgtBalance);\n    event ChiRefueled(uint _amount, address _refueler, uint _chiBalance);\n    event ChiEmptied(uint _amount, address _emptier, uint _chiBalance);\n    event GstRefueled(uint _amount, address _refueler, uint _gstBalance);\n    event GstEmptied(uint _amount, address _emptier, uint _gstBalance);\n\n/* -------------------------------------------------------------------------- */\n\n    /*\n\n        Store\n\n    */\n\n    function tankChi() public view returns (uint) {\n        return chi.balanceOf(address(this));\n    }\n\n    function tankLgt() public view returns (uint) {\n        return lgt.balanceOf(address(this));\n    }\n\n    function tankGst() public view returns (uint) {\n        return gst.balanceOf(address(this));\n    }\n\n    function refuelChi(uint _amount) public shadowPossession returns (bool) {\n        require(_amount > 0, \"Value may not be 0, (Hint) Chi tokens require 0 decimal places\");\n\n        chi.mint(_amount);\n\n        require(chi.balanceOf(address(this)) >= _amount, \"Minting chi failed\");\n\n        emit ChiRefueled(_amount, msg.sender, chi.balanceOf(address(this)));\n\n        return true;\n    }\n\n    function refuelLgt(uint _amount) public shadowPossession returns (bool) {\n        require(_amount > 0, \"Value may not be 0\");\n\n        lgt.mint(_amount);\n\n        require(lgt.balanceOf(address(this)) >= _amount, \"Minting lgt failed\");\n\n        emit LgtRefueled(_amount, msg.sender, lgt.balanceOf(address(this)));\n\n        return true;\n    }\n\n    function refuelGst(uint _amount) public shadowPossession returns (bool) {\n        require(_amount > 0, \"Value may not be 0\");\n\n        gst.mint(_amount);\n\n        require(gst.balanceOf(address(this)) >= _amount, \"Minting gst failed\");\n\n        emit GstRefueled(_amount, msg.sender, gst.balanceOf(address(this)));\n\n        return true;\n    }\n\n\n/* -------------------------------------------------------------------------- */\n\n\n    /*\n\n        Transfer\n\n    */\n\n    function emptyChiTank(uint _amount) public shadowPossession returns (bool) {\n        require(chi.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        chi.transfer(msg.sender, _amount);\n\n        emit ChiEmptied(_amount, msg.sender, chi.balanceOf(address(this)));\n\n        return true;\n    }\n\n    function emptyLgtTank(uint _amount) public shadowPossession returns (bool) {\n        require(lgt.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        lgt.transfer(msg.sender, _amount);\n\n        emit LgtEmptied(_amount, msg.sender, lgt.balanceOf(address(this)));\n\n        return true;\n    }\n\n    function emptyGstTank(uint _amount) public shadowPossession returns (bool) {\n        require(gst.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        gst.transfer(msg.sender, _amount);\n\n        emit GstEmptied(_amount, msg.sender, gst.balanceOf(address(this)));\n\n        return true;\n    }\n\n    function emptyChiTankTo(uint _amount, address _to) public shadowPossession returns (bool) {\n        require(chi.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        chi.transfer(_to, _amount);\n\n        return true;\n    }\n\n    function emptyLgtTankTo(uint _amount, address _to) public shadowPossession returns (bool) {\n        require(lgt.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        lgt.transfer(_to, _amount);\n\n        return true;\n    }\n\n    function emptyGstTankTo(uint _amount, address _to) public shadowPossession returns (bool) {\n        require(gst.balanceOf(address(this)) >= _amount, \"Tank does not have that much to empty\");\n\n        gst.transfer(_to, _amount);\n\n        return true;\n    }\n\n/* -------------------------------------------------------------------------- */\n\n    /*\n\n        Trade\n        \n    */\n\n    // Algorithm 6, Nadler's thesis (Liquid Gas Token) Pg.40\n    function lgtTradeInfo(uint _amount) public view returns (uint, uint, bool) {\n\n        uint profit = lgt.getTokenToEthInputPrice(_amount);\n\n        uint gasCost = (39141 + 36224 * _amount + 55000) * tx.gasprice; // 55000 = overhead\n\n        bool isProfitable = false;\n\n        if (profit > gasCost) {\n            isProfitable = true;\n        }\n\n        return (profit, gasCost, isProfitable);\n\n    }\n\n    // LGT ARBITRAGE\n    function lgtArb(uint _amount) public payable shadowPossession chiDiscount {\n        require(_amount > 0, \"Amount may not be 0\");\n\n        lgt.mintToSellTo(_amount, msg.value, block.timestamp, msg.sender);\n\n    }\n\n    \n}"
    },
    "contracts/6/ILGT.sol": {
      "content": "pragma solidity >=0.6.7;\n\nimport \"./ILiquidERC20.sol\";\n\ninterface ILGT is ILiquidERC20 {\n    // Minting Tokens\n    function mint(uint256 amount) external;\n\n    function mintFor(uint256 amount, address recipient) external;\n\n    function mintToLiquidity(\n        uint256 maxTokens,\n        uint256 minLiquidity,\n        uint256 deadline,\n        address recipient\n    )\n        external\n        payable\n        returns (\n            uint256 tokenAmount,\n            uint256 ethAmount,\n            uint256 liquidityCreated\n        );\n\n    function mintToSell(\n        uint256 amount,\n        uint256 minEth,\n        uint256 deadline\n    ) external returns (uint256 ethBought);\n\n    function mintToSellTo(\n        uint256 amount,\n        uint256 minEth,\n        uint256 deadline,\n        address payable recipient\n    ) external returns (uint256 ethBought);\n\n    // Freeing Tokens\n    function free(uint256 amount) external returns (bool success);\n\n    function freeFrom(uint256 amount, address owner)\n        external\n        returns (bool success);\n\n    // Buying and Freeing Tokens.\n    // It is always recommended to check the price for the amount of tokens you intend to buy\n    // and then send the exact amount of ether.\n\n    // Will refund excess ether and returns 0 instead of reverting on most errors.\n    function buyAndFree(\n        uint256 amount,\n        uint256 deadline,\n        address payable refundTo\n    ) external payable returns (uint256 ethSold);\n\n    // Spends all ether (no refunds) to buy and free as many tokens as possible.\n    function buyMaxAndFree(uint256 deadline)\n        external\n        payable\n        returns (uint256 tokensBought);\n\n    // Optimized Functions\n    // !!! USE AT YOUR OWN RISK !!!\n    // These functions are gas optimized and intended for experienced users.\n    // The function names are constructed to have 3 or 4 leading zero bytes\n    // in the function selector.\n    // Additionally, all checks have been omitted and need to be done before\n    // sending the call if desired.\n    // There are also no return values to further save gas.\n    // !!! USE AT YOUR OWN RISK !!!\n    function mintToSell9630191(uint256 amount) external;\n\n    function mintToSellTo25630722(uint256 amount, address payable recipient)\n        external;\n\n    function buyAndFree22457070633(uint256 amount) external payable;\n}\n"
    },
    "contracts/6/ILiquidERC20.sol": {
      "content": "pragma solidity >=0.6.7;\n\nimport \"./IERC20.sol\";\n\ninterface ILiquidERC20 is IERC20 {\n    // Price Query Functions\n    function getEthToTokenInputPrice(uint256 ethSold)\n        external\n        view\n        returns (uint256 tokensBought);\n\n    function getEthToTokenOutputPrice(uint256 tokensBought)\n        external\n        view\n        returns (uint256 ethSold);\n\n    function getTokenToEthInputPrice(uint256 tokensSold)\n        external\n        view\n        returns (uint256 ethBought);\n\n    function getTokenToEthOutputPrice(uint256 ethBought)\n        external\n        view\n        returns (uint256 tokensSold);\n\n    // Liquidity Pool\n    function poolTotalSupply() external view returns (uint256);\n\n    function poolTokenReserves() external view returns (uint256);\n\n    function poolBalanceOf(address account) external view returns (uint256);\n\n    function poolTransfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function addLiquidity(\n        uint256 minLiquidity,\n        uint256 maxTokens,\n        uint256 deadline\n    ) external payable returns (uint256 liquidityCreated);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256 minEth,\n        uint256 minTokens,\n        uint256 deadline\n    ) external returns (uint256 ethAmount, uint256 tokenAmount);\n\n    // Buy Tokens\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline)\n        external\n        payable\n        returns (uint256 tokensBought);\n\n    function ethToTokenTransferInput(\n        uint256 minTokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 tokensBought);\n\n    function ethToTokenSwapOutput(uint256 tokensBought, uint256 deadline)\n        external\n        payable\n        returns (uint256 ethSold);\n\n    function ethToTokenTransferOutput(\n        uint256 tokensBought,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 ethSold);\n\n    // Sell Tokens\n    function tokenToEthSwapInput(\n        uint256 tokensSold,\n        uint256 minEth,\n        uint256 deadline\n    ) external returns (uint256 ethBought);\n\n    function tokenToEthTransferInput(\n        uint256 tokensSold,\n        uint256 minEth,\n        uint256 deadline,\n        address payable recipient\n    ) external returns (uint256 ethBought);\n\n    function tokenToEthSwapOutput(\n        uint256 ethBought,\n        uint256 maxTokens,\n        uint256 deadline\n    ) external returns (uint256 tokensSold);\n\n    function tokenToEthTransferOutput(\n        uint256 ethBought,\n        uint256 maxTokens,\n        uint256 deadline,\n        address payable recipient\n    ) external returns (uint256 tokensSold);\n\n    // Events\n    event AddLiquidity(\n        address indexed provider,\n        uint256 indexed eth_amount,\n        uint256 indexed token_amount\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256 indexed eth_amount,\n        uint256 indexed token_amount\n    );\n    event TransferLiquidity(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n}\n"
    },
    "contracts/6/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}